from tkinter import *
from tkinter import filedialog
import os
import pathlib
from pathlib import Path
import logging
import re
import random

syntaxList = ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await',
    'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except',
    'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
    'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return',
    'try', 'while', 'with', 'yield', 'match', 'case', 'print', 'input', 'self', 'super',
    'int', 'str', 'bool', 'float'
]

funcList = []

currentState = ""
undoStack = []
redoStack = []
level = 0


class App(Tk):
    def __init__(self):
        super().__init__()

        self.SCREENWIDTH = self.winfo_screenwidth()
        self.SCREENHEIGHT = self.winfo_screenheight()

        self.geometry(f"{self.SCREENWIDTH}x{self.SCREENHEIGHT}") #Set GUI dimensions to user's monitor resolution
        self.title("Ciel IDE")

        self.foundDef = False
        self.foundComment = False


        self.menubar = Menu()
        self.config(menu=self.menubar)


        self.fileMenu = Menu(self.menubar, tearoff=False)
        self.menubar.add_cascade(menu=self.fileMenu, label="File")
        self.fileMenu.add_command(label= "New File", command= self.newFile)
        self.fileMenu.add_command(label= "Open", command= self.openFile)
        self.fileMenu.add_command(label= "Save", command= self.saveFile)
        self.fileMenu.add_separator()
        self.fileMenu.add_command(label= "Run", command= self.runFileCode)
        self.fileMenu.add_separator()
        self.fileMenu.add_command(label= "Exit", command= self.exitFile)

        self.editMenu = Menu(self.menubar, tearoff=False)
        self.menubar.add_cascade(menu=self.editMenu, label="Edit")
        self.editMenu.add_command(label= "Undo", command= self.undo)
        self.editMenu.add_command(label= "Redo", command= self.redo)


        self.lines = Text(self, height=self.SCREENHEIGHT/400, width=self.SCREENWIDTH, bg="#252525", foreground="#FFFFFF") #Displays number of lines in code when saved.
        self.lines.insert("1.0", "Ln 0, Char 0")
        self.lines.configure(state=DISABLED)
        self.lines.pack(side=BOTTOM)



        #Create command line.
        self.cmdFrame = Frame(self, height=self.SCREENHEIGHT/400, width=self.SCREENWIDTH)
        self.cmdFrame.pack(side=BOTTOM)
        self.cmdLine = Text(self.cmdFrame, height=self.SCREENHEIGHT/500, width=int(self.SCREENWIDTH//10.26), bg="#131212", foreground="#FFFFFF")
        self.cmdLine.pack(side=LEFT)
        self.cmdButton = Button(self.cmdFrame, width=int(self.SCREENWIDTH//7), height=int(self.SCREENHEIGHT/500), bg="#0F0F0F", foreground="#FFFFFF", text="Execute CMD", command=self.cmdExecute)
        self.cmdButton.pack(side=RIGHT)

        #Create box to enter code.
        self.mainFrame = Frame(self, height=self.SCREENHEIGHT, width=int(self.SCREENWIDTH), bg="#3B3939")
        self.mainFrame.pack()

        self.inputFrame = Frame(self.mainFrame, height=self.SCREENHEIGHT, width=int(int(self.SCREENWIDTH)//14.2), bg="#AAAAAA")
        self.inputFrame.pack(side=LEFT)
        self.inputBox = Text(self.inputFrame, wrap="none", height=int(self.SCREENHEIGHT//23), width=int(int(self.SCREENWIDTH)//14.2), bg="#3B3939", foreground="#FFFFFF", font=("Consolas"))
        self.inputBox.pack(side=TOP)
        self.inputScrollBar = Scrollbar(self.inputFrame, orient=HORIZONTAL)
        self.inputScrollBar.pack(side=BOTTOM, fill="x")
        self.inputBox.config(xscrollcommand=self.inputScrollBar.set)
        self.inputScrollBar.config(command=self.onScroll)

        self.inputBox.bind("<KeyRelease>", self.keyEvents)
        self.inputBox.bind("<Key>", self.undoRedo)

        self.outputFrame = Frame(self.mainFrame, height=self.SCREENHEIGHT, width=int(self.SCREENWIDTH)//2, bg="#222121")
        self.outputFrame.pack(side=RIGHT)
        self.outputTitle = Entry(self.outputFrame, width=int(self.SCREENWIDTH)//3, bg="#AAAAAA", foreground="#ff0000")
        self.outputTitle.pack(side=TOP)
        self.outputBox = Text(self.outputFrame, height=self.SCREENHEIGHT//2, width=int(self.SCREENWIDTH)//2, bg="#222121", foreground="#FFFFFF", font=("Consolas"))
        self.outputBox.pack(side=BOTTOM)

        self.outputTitle.insert("1", "OUTPUT")
        self.outputTitle.configure(state=DISABLED)
        self.outputBox.configure(state=DISABLED)



    def undo(self):
        global currentState
        if len(undoStack) > 1:
            # Move current state to redo stack
            redoStack.append(undoStack.pop())
            currentState = undoStack[-1]
            self.inputBox.delete("1.0", END)
            self.inputBox.insert("1.0", currentState)

    def redo(self):
        global currentState
        if redoStack:
            state = redoStack.pop()
            undoStack.append(state)
            currentState = state
            self.inputBox.delete("1.0", END)
            self.inputBox.insert("1.0", state)


    #Grabs CMD command and runs it.
    def cmdExecute(self):
        self.rawCommand = '(self.cmdLine.get("1.0", END))'
        print(self.rawCommand)
        self.cmdCommand = compile(f"os.system({self.rawCommand})", "cmdcode", "exec")
        exec(self.cmdCommand)

    def keyEvents(self, event): #general function for keyevents in inputBox widget
        global level
        self.key = event.keysym
        self.indent = "    "

        for x in range(level):
            self.indent = self.indent + "    "

        if self.key == "colon":
            currentIndex = self.inputBox.index("insert")
            self.inputBox.insert(currentIndex, "\n" + f"{self.indent}")
            level = level + 1

        if self.key == "Return":
            level = 0
            self.indent = "    "

        if self.key == "Tab":
            currentIndex = float(self.inputBox.index("insert"))
            self.inputBox.delete(float(currentIndex-0.1), float(currentIndex))
            self.inputBox.insert(float(currentIndex-0.1), "    ")


        self.lines.configure(state=NORMAL) #Update display showing number of lines and characters of file.
        self.lines.delete("1.0", END)
        self.Ln = int(self.inputBox.index('end-1c').split(".")[0])
        self.Char = len(self.inputBox.get("1.0", END))
        self.lines.insert("1.0", f"Ln {self.Ln}, Char {self.Char}")
        self.lines.configure(state=DISABLED)

        self.inputBox.tag_remove("highlight", "1.0", END) # syntax highlightings
        self.inputBox.tag_remove("function", "1.0", END)
        self.inputBox.tag_remove("comment", "1.0", END)
        funcList.clear()

        allCode = self.inputBox.get("1.0", END)
        allLines = allCode.splitlines()



        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\b\w+\b', line):

                word = match.group()
                if word in syntaxList:
                    startCol = match.start()
                    endCol = match.end()
                    self.inputBox.tag_add("highlight", f"{lineNum}.{startCol}", f"{lineNum}.{endCol}")

        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\b\w+\b', line):

                word = match.group()
                if word == "def" or word == "class":
                    self.foundDef = True
                    print("FOUND DEF")
                    continue
                    return

                elif self.foundDef == True:
                    funcList.append(word)
                    print(funcList)
                    self.foundDef = False


                if word in funcList:
                            startCol = match.start()
                            endCol = match.end()
                            self.inputBox.tag_add("function", f"{lineNum}.{startCol}", f"{lineNum}.{endCol}")

        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\#', line):

                self.foundComment = True
                print("found comment")

                startCol = match.start()
                endCol = match.end()
                self.inputBox.tag_add("comment", f"{lineNum}.{startCol}", f"{lineNum}.{END}")


        self.inputBox.tag_config("highlight", foreground="#FF5555")
        self.inputBox.tag_config("function", foreground="#BEDCFE")
        self.inputBox.tag_config("comment", foreground="#A8FFB0")

        if self.key != "F3" or self.key != "F4":
            global currentState
            newState = self.inputBox.get("1.0", END)
            if newState != currentState:
                undoStack.append(newState)
                currentState = newState




    def undoRedo(self, event):
        self.key = event.keysym
        if self.key == "F3":
            self.undo()
        elif self.key == "F4":
            self.redo()
        elif self.key == "F5":
            self.runFileCode()

    #Create new Ciel window.
    def newFile(self):
        newWindow(self)

    #Import Python file from local directory.
    def openFile(self):
        self.file = filedialog.askopenfile(defaultextension=".py",
                                           filetypes=[("Python File",".py"),
                                                      ("All Files", ".*")
                                                      ])

        self.pythonFile = str(self.file) #Getting name of Python file.
        self.replacer = ["<_io.TextIOWrapper name='", "' mode='r' encoding='cp1252'>"] #Getting rid of extra stuff to isolate the filename.
        for sub in self.replacer:
            self.pythonFile = self.pythonFile.replace(sub, "")
        print(self.pythonFile)

        self.fileCode = open(self.pythonFile, "r") #Open file in read mode.
        print(self.fileCode)
        linePos = 0
        letterPos = 0
        for x in self.fileCode:
            linePos += 1
            for y in x:
                letterPos += 1
                self.inputBox.insert(f"{linePos}.{letterPos}", y) #Insert contents of Python file in editor.
            self.inputBox.insert(f"{linePos}.{letterPos+1}", "\n")

    def saveFile(self):
        self.file = filedialog.asksaveasfile(defaultextension=".py",
                                             filetypes=[("Python File",".py"),
                                                        ("All Files", ".*")
                                                        ])

        self.file.write(str(self.inputBox.get("1.0", END)))
        self.file.close()
        print(self.file)



    def runFileCode(self):
        self.rawCode = self.inputBox.get("1.0", END)

        self.printReplacer = ["print("] #changing print statements into local function so it goes into outputBox.
        for sub in self.printReplacer:
            self.rawCode = self.rawCode.replace(sub, "self.printInto(")

        print(self.rawCode)
        try:
            self.codeCommand = compile(self.rawCode, "code", "exec") #Grab all code in editor.
            exec(self.codeCommand) #Runs the code.
        except Exception as e:
            self.log_error(e)
            logging.error("Exception occurred", exc_info=True)

    def log_error(self, message):
        self.outputBox.configure(state=NORMAL)

        self.outputBox.insert("1.0", f"ERROR: {message} \n")
        self.outputBox.configure(state=DISABLED)


    def exitFile(self):
        self.destroy()

    def printInto(self, x):
        self.outputBox.configure(state=NORMAL)
        self.outputBox.delete("1.0", END)
        self.outputBox.insert("1.0", x)
        self.outputBox.configure(state=DISABLED)

    def onScroll(self, *args):
        self.inputBox.xview(*args)


#Copy of main app for when user clicks "New File".
class newWindow(Toplevel):
    def __init__(self, parent):
        super().__init__(parent)

        self.SCREENWIDTH = self.winfo_screenwidth()
        self.SCREENHEIGHT = self.winfo_screenheight()

        self.geometry(f"{self.SCREENWIDTH}x{self.SCREENHEIGHT}") #Set GUI dimensions to user's monitor resolution
        self.title("Ciel IDE")

        self.foundDef = False
        self.foundComment = False


        self.menubar = Menu()
        self.config(menu=self.menubar)


        self.fileMenu = Menu(self.menubar, tearoff=False)
        self.menubar.add_cascade(menu=self.fileMenu, label="File")
        self.fileMenu.add_command(label= "New File", command= self.newFile)
        self.fileMenu.add_command(label= "Open", command= self.openFile)
        self.fileMenu.add_command(label= "Save", command= self.saveFile)
        self.fileMenu.add_separator()
        self.fileMenu.add_command(label= "Run", command= self.runFileCode)
        self.fileMenu.add_separator()
        self.fileMenu.add_command(label= "Exit", command= self.exitFile)

        self.editMenu = Menu(self.menubar, tearoff=False)
        self.menubar.add_cascade(menu=self.editMenu, label="Edit")
        self.editMenu.add_command(label= "Undo", command= self.undo)
        self.editMenu.add_command(label= "Redo", command= self.redo)


        self.lines = Text(self, height=self.SCREENHEIGHT/400, width=self.SCREENWIDTH, bg="#252525", foreground="#FFFFFF") #Displays number of lines in code when saved.
        self.lines.insert("1.0", "Ln 0, Char 0")
        self.lines.configure(state=DISABLED)
        self.lines.pack(side=BOTTOM)



        #Create command line.
        self.cmdFrame = Frame(self, height=self.SCREENHEIGHT/400, width=self.SCREENWIDTH)
        self.cmdFrame.pack(side=BOTTOM)
        self.cmdLine = Text(self.cmdFrame, height=self.SCREENHEIGHT/500, width=int(self.SCREENWIDTH//10.26), bg="#131212", foreground="#FFFFFF")
        self.cmdLine.pack(side=LEFT)
        self.cmdButton = Button(self.cmdFrame, width=int(self.SCREENWIDTH//7), height=int(self.SCREENHEIGHT/500), bg="#0F0F0F", foreground="#FFFFFF", text="Execute CMD", command=self.cmdExecute)
        self.cmdButton.pack(side=RIGHT)

        #Create box to enter code.
        self.mainFrame = Frame(self, height=self.SCREENHEIGHT, width=int(self.SCREENWIDTH), bg="#3B3939")
        self.mainFrame.pack()

        self.inputFrame = Frame(self.mainFrame, height=self.SCREENHEIGHT, width=int(int(self.SCREENWIDTH)//14.2), bg="#AAAAAA")
        self.inputFrame.pack(side=LEFT)
        self.inputBox = Text(self.inputFrame, wrap="none", height=int(self.SCREENHEIGHT//23), width=int(int(self.SCREENWIDTH)//14.2), bg="#3B3939", foreground="#FFFFFF", font=("Consolas"))
        self.inputBox.pack(side=TOP)
        self.inputScrollBar = Scrollbar(self.inputFrame, orient=HORIZONTAL)
        self.inputScrollBar.pack(side=BOTTOM, fill="x")
        self.inputBox.config(xscrollcommand=self.inputScrollBar.set)
        self.inputScrollBar.config(command=self.onScroll)

        self.inputBox.bind("<KeyRelease>", self.keyEvents)
        self.inputBox.bind("<Key>", self.undoRedo)

        self.outputFrame = Frame(self.mainFrame, height=self.SCREENHEIGHT, width=int(self.SCREENWIDTH)//2, bg="#222121")
        self.outputFrame.pack(side=RIGHT)
        self.outputTitle = Entry(self.outputFrame, width=int(self.SCREENWIDTH)//3, bg="#AAAAAA", foreground="#ff0000")
        self.outputTitle.pack(side=TOP)
        self.outputBox = Text(self.outputFrame, height=self.SCREENHEIGHT//2, width=int(self.SCREENWIDTH)//2, bg="#222121", foreground="#FFFFFF", font=("Consolas"))
        self.outputBox.pack(side=BOTTOM)

        self.outputTitle.insert("1", "OUTPUT")
        self.outputTitle.configure(state=DISABLED)
        self.outputBox.configure(state=DISABLED)



    def undo(self):
        global currentState
        if len(undoStack) > 1:
            # Move current state to redo stack
            redoStack.append(undoStack.pop())
            currentState = undoStack[-1]
            self.inputBox.delete("1.0", END)
            self.inputBox.insert("1.0", currentState)

    def redo(self):
        global currentState
        if redoStack:
            state = redoStack.pop()
            undoStack.append(state)
            currentState = state
            self.inputBox.delete("1.0", END)
            self.inputBox.insert("1.0", state)


    #Grabs CMD command and runs it.
    def cmdExecute(self):
        self.rawCommand = '(self.cmdLine.get("1.0", END))'
        print(self.rawCommand)
        self.cmdCommand = compile(f"os.system({self.rawCommand})", "cmdcode", "exec")
        exec(self.cmdCommand)

    def keyEvents(self, event): #general function for keyevents in inputBox widget
        global level
        self.key = event.keysym
        self.indent = "    "

        for x in range(level):
            self.indent = self.indent + "    "

        if self.key == "colon":
            currentIndex = self.inputBox.index("insert")
            self.inputBox.insert(currentIndex, "\n" + f"{self.indent}")
            level = level + 1

        if self.key == "Return":
            level = 0
            self.indent = "    "

        if self.key == "Tab":
            currentIndex = float(self.inputBox.index("insert"))
            self.inputBox.delete(float(currentIndex-0.1), float(currentIndex))
            self.inputBox.insert(float(currentIndex-0.1), "    ")


        self.lines.configure(state=NORMAL) #Update display showing number of lines and characters of file.
        self.lines.delete("1.0", END)
        self.Ln = int(self.inputBox.index('end-1c').split(".")[0])
        self.Char = len(self.inputBox.get("1.0", END))
        self.lines.insert("1.0", f"Ln {self.Ln}, Char {self.Char}")
        self.lines.configure(state=DISABLED)

        self.inputBox.tag_remove("highlight", "1.0", END) # syntax highlightings
        self.inputBox.tag_remove("function", "1.0", END)
        self.inputBox.tag_remove("comment", "1.0", END)
        funcList.clear()

        allCode = self.inputBox.get("1.0", END)
        allLines = allCode.splitlines()



        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\b\w+\b', line):

                word = match.group()
                if word in syntaxList:
                    startCol = match.start()
                    endCol = match.end()
                    self.inputBox.tag_add("highlight", f"{lineNum}.{startCol}", f"{lineNum}.{endCol}")

        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\b\w+\b', line):

                word = match.group()
                if word == "def" or word == "class":
                    self.foundDef = True
                    print("FOUND DEF")
                    continue
                    return

                elif self.foundDef == True:
                    funcList.append(word)
                    print(funcList)
                    self.foundDef = False


                if word in funcList:
                            startCol = match.start()
                            endCol = match.end()
                            self.inputBox.tag_add("function", f"{lineNum}.{startCol}", f"{lineNum}.{endCol}")

        for lineNum, line in enumerate(allLines, start=1):
            for match in re.finditer(r'\#', line):

                self.foundComment = True
                print("found comment")

                startCol = match.start()
                endCol = match.end()
                self.inputBox.tag_add("comment", f"{lineNum}.{startCol}", f"{lineNum}.{END}")


        self.inputBox.tag_config("highlight", foreground="#FF5555")
        self.inputBox.tag_config("function", foreground="#BEDCFE")
        self.inputBox.tag_config("comment", foreground="#A8FFB0")

        if self.key != "F3" or self.key != "F4":
            global currentState
            newState = self.inputBox.get("1.0", END)
            if newState != currentState:
                undoStack.append(newState)
                currentState = newState




    def undoRedo(self, event):
        self.key = event.keysym
        if self.key == "F3":
            self.undo()
        elif self.key == "F4":
            self.redo()
        elif self.key == "F5":
            self.runFileCode()

    #Create new Ciel window.
    def newFile(self):
        newWindow(self)

    #Import Python file from local directory.
    def openFile(self):
        self.file = filedialog.askopenfile(defaultextension=".py",
                                           filetypes=[("Python File",".py"),
                                                      ("All Files", ".*")
                                                      ])

        self.pythonFile = str(self.file) #Getting name of Python file.
        self.replacer = ["<_io.TextIOWrapper name='", "' mode='r' encoding='cp1252'>"] #Getting rid of extra stuff to isolate the filename.
        for sub in self.replacer:
            self.pythonFile = self.pythonFile.replace(sub, "")
        print(self.pythonFile)

        self.fileCode = open(self.pythonFile, "r") #Open file in read mode.
        print(self.fileCode)
        linePos = 0
        letterPos = 0
        for x in self.fileCode:
            linePos += 1
            for y in x:
                letterPos += 1
                self.inputBox.insert(f"{linePos}.{letterPos}", y) #Insert contents of Python file in editor.
            self.inputBox.insert(f"{linePos}.{letterPos+1}", "\n")

    def saveFile(self):
        self.file = filedialog.asksaveasfile(defaultextension=".py",
                                             filetypes=[("Python File",".py"),
                                                        ("All Files", ".*")
                                                        ])

        self.file.write(str(self.inputBox.get("1.0", END)))
        self.file.close()
        print(self.file)



    def runFileCode(self):
        self.rawCode = self.inputBox.get("1.0", END)

        self.printReplacer = ["print("] #changing print statements into local function so it goes into outputBox.
        for sub in self.printReplacer:
            self.rawCode = self.rawCode.replace(sub, "self.printInto(")

        print(self.rawCode)
        try:
            self.codeCommand = compile(self.rawCode, "code", "exec") #Grab all code in editor.
            exec(self.codeCommand) #Runs the code.
        except Exception as e:
            self.log_error(e)
            logging.error("Exception occurred", exc_info=True)

    def log_error(self, message):
        self.outputBox.configure(state=NORMAL)

        self.outputBox.insert("1.0", f"ERROR: {message} \n")
        self.outputBox.configure(state=DISABLED)


    def exitFile(self):
        self.destroy()

    def printInto(self, x):
        self.outputBox.configure(state=NORMAL)
        self.outputBox.delete("1.0", END)
        self.outputBox.insert("1.0", x)
        self.outputBox.configure(state=DISABLED)

    def onScroll(self, *args):
        self.inputBox.xview(*args)

def initalizeApp():
    loader.destroy()
    app = App()
    app.mainloop()

loader = Tk()
loader.title("Ciel IDE")
loader.resizable(0,0)
loadingScreen = Frame(loader, width=600, height=600, bg="#252525")
loadingScreen.pack()
appTitle = Label(loadingScreen, text="Ciel IDE", font=("Consolas", 20), fg="#FFFFFF", bg="#252525", width=20, height=4)
appTitle.pack(side=TOP)
initalizeMessage = Label(loadingScreen, text="Initalizing...", font=("Consolas", 10), fg="#FFFFFF", bg="#252525")
initalizeMessage.pack(side=TOP, pady=5)
authorDetails = Label(loadingScreen, text="Made by Veodyne\nÂ© 2025", font=("Consolas", 10), fg="#FFFFFF", bg="#252525")
authorDetails.pack(side=LEFT)
loader.after(random.randint(0, 5000), initalizeApp)
loader.mainloop()




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































